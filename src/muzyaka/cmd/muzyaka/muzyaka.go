package muzyaka

import (
	"log/slog"
	"os"
	_ "src/docs" // docs is generated by Swag CLI, you have to import it.
	"src/internal/lib/logger/handlers/slogpretty"
)

const (
	envLocal = "local"
	envDev   = "dev"
	envProd  = "prod"
)

// TODO: мб не полагаться на проверки от репозитория, а осуществлять проверки в юзкейсах
// TODO: не создавать бакет если он уже существует?
func App() {
	//cfg := config.MustLoad()
	//
	//logger := setupLogger(cfg.Env)
	//logger.Info("Logger init")
	//
	//done := make(chan os.Signal, 1)
	//signal.Notify(done, os.Interrupt, syscall.SIGINT, syscall.SIGTERM)
	//
	//dsn := "host=localhost user=postgres password=123 dbname=postgres port=5432"
	//db, err := gorm.Open(postgres2.Open(dsn), &gorm.Config{})
	//if err != nil {
	//	logger.Error(err.Error())
	//}
	//
	//ctx := context.Background()
	//
	//if err != nil {
	//	logger.Error(err.Error())
	//}
	//
	//tokenProvider := jwt2.NewTokenProvider("secret", time.Hour)
	//
	//producer, err := kafka.NewProducer("localhost:29092")
	//if err != nil {
	//	logger.Error(err.Error())
	//}
	//
	//userRep := postgres.NewUserRepository(db)
	//albumRep := postgres3.NewAlbumRepository(db)
	//trackRep := postgres8.NewTrackRepository(db)
	//
	//outboxRep := postgres6.NewOutboxRepo(db)
	//
	//encryptor := usecase.NewEncryptor()
	//authUseCase := usecase.NewAuthUseCase(tokenProvider, userRep, encryptor)
	//musicianUseCase := usecase3.NewMusicianUseCase(musicianRep)
	//albumUseCase := usecase2.NewAlbumUseCase(albumRep, trackStorage, trackRep)
	//trackUseCase := usecase8.NewTrackUseCase(trackRep, trackStorage)
	//outbox := usecase5.NewOutboxUseCase(producer, outboxRep)
	//
	//go func() {
	//	for {
	//		select {
	//		case <-done:
	//			logger.Info("stopping cron")
	//			return
	//		default:
	//			outbox.ProduceMessages()
	//			time.Sleep(10 * time.Second)
	//		}
	//	}
	//}()
	//
	//musicianMiddleware := (func(h http.Handler) http.Handler {
	//	return middleware.CheckMusicianLevelPermissions(h, authUseCase)
	//})
	//
	//checkForMusicianId := (func(h http.Handler) http.Handler {
	//	return middleware2.CheckIsUserRelatedToMusician(h, musicianUseCase)
	//})
	//
	//checkIsAlbumRelated := (func(h http.Handler) http.Handler {
	//	return middleware2.CheckAlbumOwnership(h, albumUseCase, musicianUseCase)
	//})
	//
	//basicAuthMiddleware := (func(h http.Handler) http.Handler {
	//	return middleware.JwtParseMiddleware(h, authUseCase)
	//})
	//
	//router := chi.NewRouter()
	//
	////auth
	//router.Post("/api/auth/sign-up/user", delivery.SignUp(authUseCase))
	//router.Post("/api/auth/sign-in", delivery.SignIn(authUseCase))
	//router.Post("/api/auth/sign-up/musician", delivery.SignUpMusician(authUseCase))
	//
	//// album
	//router.Group(func(r chi.Router) {
	//	r.Use(musicianMiddleware)
	//	r.With(checkForMusicianId).Post("/api/musician/{musician_id}/album", delivery2.AddAlbumWithTracks(albumUseCase))
	//
	//	r.Group(func(r chi.Router) {
	//		r.Use(checkIsAlbumRelated)
	//		r.Delete("/api/album/{id}", delivery2.DeleteAlbum(albumUseCase))
	//	})
	//})
	//
	//// Other opened requests
	//router.Group(func(r chi.Router) {
	//	r.Use(basicAuthMiddleware)
	//
	//	r.Get("/api/track", delivery7.FindTracks(trackUseCase))
	//	r.Get("/api/track/{id}", delivery7.GetTrack(trackUseCase))
	//	r.Get("/api/musician/{musician_id}", delivery5.GetMusician(musicianUseCase))
	//	r.Get("/api/album/{id}/tracks", delivery2.GetAllTracks(albumUseCase))
	//	r.Get("/api/album/{id}", delivery2.GetAlbum(albumUseCase))
	//})
	//
	//// Swagger
	//router.Get("/swagger/*", httpSwagger.Handler(
	//	httpSwagger.URL("http://localhost:8080/swagger/doc.json"), //The url pointing to API definition
	//))
	//srv := &http.Server{
	//	Addr:    "localhost:8080",
	//	Handler: router,
	//}
	//
	//go func() {
	//	if err := srv.ListenAndServe(); err != nil {
	//		logger.Error("failed to start server")
	//	}
	//}()
	//
	//<-done
	//
	//logger.Info("stopping server")
	//
	//ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	//defer cancel()
	//
	//if err := srv.Shutdown(ctx); err != nil {
	//	logger.Error("failed to stop server")
	//	return
	//}
	//
	//logger.Info("server stopped")
}

func setupLogger(env string) *slog.Logger {
	var log *slog.Logger

	switch env {
	case envLocal:
		log = setupPrettySlog()
	case envDev:
		log = slog.New(
			slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{Level: slog.LevelDebug}),
		)
	case envProd:
		log = slog.New(
			slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{Level: slog.LevelInfo}),
		)
	default: // If env config is invalid, set prod settings by default due to security
		log = slog.New(
			slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{Level: slog.LevelInfo}),
		)
	}

	return log
}

func setupPrettySlog() *slog.Logger {
	opts := slogpretty.PrettyHandlerOptions{
		SlogOpts: &slog.HandlerOptions{
			Level: slog.LevelDebug,
		},
	}

	handler := opts.NewPrettyHandler(os.Stdout)

	return slog.New(handler)
}
