package muzyaka

import (
	"context"
	"github.com/go-chi/chi/v5"
	"github.com/rs/zerolog/log"
	httpSwagger "github.com/swaggo/http-swagger"
	postgres2 "gorm.io/driver/postgres"
	"gorm.io/gorm"
	"net/http"
	"os"
	"os/signal"
	_ "src/docs" // docs is generated by Swag CLI, you have to import it.
	delivery2 "src/internal/domain/album/delivery"
	"src/internal/domain/album/repository/postgres"
	"src/internal/domain/album/usecase"
	"src/internal/domain/track/delivery"
	postgres3 "src/internal/domain/track/repository/postgres"
	usecase2 "src/internal/domain/track/usecase"
	"syscall"
	"time"
)

const (
	envLocal = "local"
	envDev   = "dev"
	envProd  = "prod"
)

// TODO: мб не полагаться на проверки от репозитория, а осуществлять проверки в юзкейсах
// TODO: не создавать бакет если он уже существует?
func App() {
	log.Info().Msg("Logger init")

	done := make(chan os.Signal, 1)
	signal.Notify(done, os.Interrupt, syscall.SIGINT, syscall.SIGTERM)

	dsn := "host=localhost user=postgres password=123 dbname=postgres port=5432"
	db, err := gorm.Open(postgres2.Open(dsn), &gorm.Config{})
	if err != nil {
		log.Error().Err(err)
	}

	ctx := context.Background()

	if err != nil {
		log.Error().Err(err)
	}

	albumRep := postgres.NewAlbumRepository(db)
	trackRep := postgres3.NewTrackRepository(db)

	albumUseCase := usecase.NewAlbumUseCase(albumRep)
	trackUseCase := usecase2.NewTrackUseCase(trackRep)

	router := chi.NewRouter()

	router.Get("/api/track", delivery.FindTracks(trackUseCase))
	router.Get("/api/track/{id}", delivery.GetTrack(trackUseCase))
	router.Get("/api/album/{id}/tracks", delivery2.GetAllTracks(albumUseCase))
	router.Get("/api/album/{id}", delivery2.GetAlbum(albumUseCase))

	// Swagger
	router.Get("/swagger/*", httpSwagger.Handler(
		httpSwagger.URL("http://localhost:8080/swagger/doc.json"), //The url pointing to API definition
	))
	srv := &http.Server{
		Addr:    "localhost:8080",
		Handler: router,
	}

	go func() {
		if err := srv.ListenAndServe(); err != nil {
			log.Error().Msg("failed to start server")
		}
	}()

	<-done

	log.Info().Msg("stopping server")

	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	if err := srv.Shutdown(ctx); err != nil {
		log.Error().Msg("failed to stop server")
		return
	}

	log.Info().Msg("server stopped")
}
